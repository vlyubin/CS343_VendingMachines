The first part of testing is incorrect usage testing. To do this, we check the behaviour of the program
on various invalid usages, like too many parameters or invalid values:

linux028:~/cs343/a6/CS343_A6> make
make: Nothing to be done for `all'.

linux028:~/cs343/a6/CS343_A6> ./soda 1 2 3 
Usage: ./soda [ config-file [ random-seed (> 0) ] ]

linux028:~/cs343/a6/CS343_A6> ./soda UNEXISTING_CONFIG_FILE
Error: could not open input file "UNEXISTING_CONFIG_FILE"

linux028:~/cs343/a6/CS343_A6> ./soda soda.config -1
Usage: ./soda [ config-file [ random-seed (> 0) ] ]

linux028:~/cs343/a6/CS343_A6> ./soda soda.config SHOULD_BE_INT
Usage: ./soda [ config-file [ random-seed (> 0) ] ]

We correctly handle invalid inputs.

---------------------------------------------------------------------

The huge part of testing comes from assertions placed in the code, that will force the program to quit
when encountering abnormal condition. The tests in the code are the following:

// TODO

Additionally we can check that no deadlocks or other problems arise. We've made a script that will allow me to
check the possible input combos. For each combo of input parameters, we generate appropriate config file, and
run our program with it. If the deadlock will happen, the script will stop in the middle, without printing
FINISHED message. If asseriton fails, the message will get printed to console.
Here's the result of running the tests:

linux028:~/cs343/a6/CS343_A6> cat testscript.sh 
#!/bin/bash -e

# Example input file:
#
# SodaCost                2    # Manufacturer Suggested Retail Price (MSRP) per bottle
# NumStudents             2    # number of students to create
# MaxPurchases            8    # maximum number of bottles a student purchases
# NumVendingMachines      3    # number of vending machines
# MaxStockPerFlavour      5    # maximum number of bottles of each flavour in a vending machine
# MaxShippedPerFlavour    3    # maximum number of bottles of each flavour generated by the bottling
#                              #    plant per production run
# TimeBetweenShipments    3    # length of time between shipment pickup
# ParentalDelay           2    # length of time between new deposits of funds
# NumCouriers             1    # maximum number of couriers in the pool

`touch testfile.config`

for SodaCost in `seq 1 3`;
do
for NumStudents in `seq 1 4`;
do
for MaxPurchases in `seq 1 3`;
do
for NumVendingMachines in `seq 1 3`;
do
for MaxStockPerFlavour in `seq 1 2`;
do
for MaxShippedPerFlavour in `seq 1 2`;
do
for TimeBetweenShipments in `seq 4 4`;
do
for ParentalDelay in `seq 1 1`;
do
for NumCouriers in `seq 1 2`;
do
for seed in `seq 1 3`;
do

`echo "SodaCost $SodaCost
NumStudents $NumStudents
MaxPurchases $MaxPurchases
NumVendingMachines $NumVendingMachines
MaxStockPerFlavour $MaxStockPerFlavour
MaxShippedPerFlavour $MaxShippedPerFlavour
TimeBetweenShipments $TimeBetweenShipments
ParentalDelay $ParentalDelay
NumCouriers $NumCouriers
" >  testfile.config`

echo "Running soda testfile.config $seed"
`./soda testfile.config $seed >/dev/null`

done
done
done
done
done
done
done
done
done
done

echo "VERIFICATION FINISHED."
linux028:~/cs343/a6/CS343_A6> make
make: Nothing to be done for `all'.
linux028:~/cs343/a6/CS343_A6> sh testscript.sh 
Running soda testfile.config 1
Running soda testfile.config 2
Running soda testfile.config 3
Running soda testfile.config 1
Running soda testfile.config 2

// MORE OUTPUT

Running soda testfile.config 1
Running soda testfile.config 2
Running soda testfile.config 3
VERIFICATION FINISHED.

So we see that no deadlocks happened throughout the execution, as well as no assertions
were triggered.

---------------------------------------------------------------------

The last part of testing comes from inspection of interesting cases.

// TODO
